# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2025 Fundament Software SPC <https://fundament.software>

# FIXME: type of universe
# we need to wrap this, and wrap takes a type in star-10
# so we have to settle for star-9
let omega = 9
# FIXME: apparently variables aren't allowed here
#let universe = type_(omega, 1)
let universe = type_(9, 1)
let type-omega = type_(9, 0)
let type-omega+1 = type_(10, 0)

# nor expressions
####let implicit-wrap = lambda_curry ((T : type_(omega + 1, 0)))
	lambda (x : T)
		wrap T x

let implicit-wrap = lambda_curry ((T : type-omega+1))
	lambda (x : T)
		wrap T x

let implicit-unwrap = lambda_implicit (T : type-omega+1)
	lambda (x : wrapped(T))
		unwrap T x

####let implicit-unstrict-wrap = lambda_curry ((T : type-omega+1))
		lambda (x : T)
			unstrict-wrap T x

	let implicit-unstrict-unwrap = lambda_implicit (T : type-omega+1)
		lambda (x : unstrict-wrapped(T))
			unstrict-unwrap T x

let tuple-of-implicit = lambda_implicit (T : type-omega+1)
	lambda_single (xs : T)
		xs

let explicit-unwrap = unwrap
let wrap = implicit-wrap
let unwrap = implicit-unwrap
####let unstrict-wrap = implicit-unstrict-wrap
	let unstrict-unwrap = implicit-unstrict-unwrap

let host-bool-wrap            = intrinsic "return terms.strict_value.host_bool_type"      : wrapped(host-type)
let host-string-wrap          = intrinsic "return terms.strict_value.host_string_type"    : wrapped(host-type)
let host-syntax-wrap          = intrinsic "return terms.host_syntax_type"          : wrapped(host-type)
let host-environment-wrap     = intrinsic "return terms.host_environment_type"     : wrapped(host-type)
let host-goal-wrap            = intrinsic "return terms.host_goal_type"            : wrapped(host-type)
let host-inferrable-term-wrap = intrinsic "return terms.host_inferrable_term_type" : wrapped(host-type)
let host-checkable-term-wrap  = intrinsic "return terms.host_checkable_term_type"  : wrapped(host-type)
let host-lua-error-wrap       = intrinsic "return terms.host_lua_error_type"       : wrapped(host-type)

let host-bool            = unwrap(host-bool-wrap)
let host-string          = unwrap(host-string-wrap)
let host-syntax          = unwrap(host-syntax-wrap)
let host-environment     = unwrap(host-environment-wrap)
let host-goal            = unwrap(host-goal-wrap)
let host-inferrable-term = unwrap(host-inferrable-term-wrap)
let host-checkable-term  = unwrap(host-checkable-term-wrap)
let host-lua-error       = unwrap(host-lua-error-wrap)
	
let srel = lambda_implicit (U : type-omega+1)
	unwrap
		intrinsic
			""""
				return U.notail(evaluator.gen_base_operator("#srel", function(target)
					return U.notail(terms.typed_term.srel_type(target))
				end))
			:
			wrapped (forall ((target : U)) -> (rel : U))

let variance = lambda_implicit (U : type-omega+1)
	unwrap
		intrinsic
			""""
				return U.notail(evaluator.gen_base_operator("#variance", function(target)
					return U.notail(terms.typed_term.variance_type(target))
				end))
			:
			wrapped (forall ((target : U)) -> (res : U))

let subtyping = intrinsic "return evaluator.UniverseOmegaRelation" : srel(type-omega)

let tuple-desc-type = lambda_implicit (U : universe)
	unwrap
		intrinsic
			""""
				return U.notail(evaluator.gen_base_operator("#tuple-desc-type", function(a_universe)
					return U.notail(terms.typed_term.tuple_desc_type(a_universe))
				end))
			:
			wrapped (forall ((a-universe : U)) -> (desc : U))

let tuple-desc-relation = intrinsic "return evaluator.TupleDescRelation" : srel(tuple-desc-type(type-omega))

let _|_ = lambda_implicit (U : type-omega+1)
	unwrap
		intrinsic
			""""
				return U.notail(evaluator.gen_base_operator("#union", function(left, right)
					return U.notail(terms.typed_term.union_type(left, right))
				end))
			:
			wrapped (forall (left : U, right : U) -> (union : U))

let _&_ = lambda_implicit (U : type-omega+1)
	unwrap
		intrinsic
			""""
				return U.notail(evaluator.gen_base_operator("#intersection", function(left, right)
					return U.notail(terms.typed_term.intersection_type(left, right))
				end))
			:
			wrapped (forall (left : U, right : U) -> (intersection : U))

let covariant = lambda_curry (U : universe, a : U)
	unwrap
		intrinsic
			""""
				return U.notail(evaluator.gen_base_operator("#covariant", function(rel)
					local positive = terms.typed_term.literal(terms.strict_value.host_value(true))
					return U.notail(terms.typed_term.variance_cons(positive, rel))
				end))
			:
			wrapped (forall ((rel : srel(a))) -> (covariant-rel : variance(a)))

let contravariant = lambda_curry (U : universe, a : U)
	unwrap
		intrinsic
			""""
				return U.notail(evaluator.gen_base_operator("#contravariant", function(rel)
					local positive = terms.typed_term.literal(terms.strict_value.host_value(false))
					return U.notail(terms.typed_term.variance_cons(positive, rel))
				end, "rel"))
			:
			wrapped (forall ((rel : srel(a))) -> (contravariant-rel : variance(a)))


let tuple-type = lambda_implicit (U : universe)
	unwrap
		intrinsic
			""""
				return U.notail(evaluator.gen_base_operator("#tuple-type", function(desc)
					return U.notail(terms.typed_term.tuple_type(desc))
				end, "desc"))
			:
			wrapped (forall ((desc : tuple-desc-type(U))) -> (T : U))

let host-tuple-type =
	unwrap
		intrinsic
			""""
				return U.notail(evaluator.gen_base_operator("#host-tuple-type", function(desc)
					return U.notail(terms.typed_term.host_tuple_type(desc))
				end, "desc"))
			:
			wrapped (forall ((desc : tuple-desc-type(host-type))) -> (T : host-type))

let host-family-sig-variances = lambda (signature : type_(1, 0))
	let inner = intrinsic
		""""
			return base_env.convert_sig
		:
		host-func-type ((signature : wrapped(type_(1, 0)))) -> ((srel_type : wrapped(type_(1, 0))))
	let (srels-t) = inner(wrap(signature))
	unwrap(srels-t)

let host-string-concat = intrinsic "return function(a, b) return U.notail(a .. b) end" :
	host-func-type (a : host-string, b : host-string) -> ((c : host-string))

let host-unique-id-wrap = intrinsic
	""""
		local id = { name = "unique_id" }
		evaluator.register_host_srel(id, evaluator.IndepTupleRelation())
		return U.notail(terms.strict_value.host_user_defined_type(id, terms_gen.declare_array(terms.strict_value)()))
	:
	wrapped(host-type)
let host-unique-id = unwrap(host-unique-id-wrap)
let new-host-unique-id = lambda (name : host-string)
	let source0 = "return { name = \""
	let (source1) = host-string-concat(source0, name)
	let (source2) = host-string-concat(source1, "\" }")
	intrinsic source2 : host-unique-id

let new-host-type-family = lambda (unique-id : host-unique-id, signature : type_(1, 0), variance : host-family-sig-variances(signature))
	let inner = intrinsic
		""""
			return base_env.new_host_type_family
		:
		host-func-type (
				unique-id  : host-unique-id,
				signature_ : wrapped(type_(1, 0)),
				variance_  : wrapped(host-family-sig-variances(unwrap(signature_))))
			->
			((family : wrapped(unwrap(signature_))))
	let (family) = inner(unique-id, wrap(signature), wrap(variance))
	unwrap(family)
let new-host-type = lambda (unique-id : host-unique-id)
	let Tfam = new-host-type-family unique-id
		forall () -> (T : host-type)
		tuple-of-implicit()
	Tfam()

let host-array-type = new-host-type-family new-host-unique-id("array")
	forall ((T : host-type)) -> (T : host-type)
	tuple-of-implicit covariant(subtyping)

let host-array-new = lambda (T : host-type)
	let inner = intrinsic
		""""
			local function array_new()
				return {}
			end
			return array_new
		:
		host-func-type () -> ((arr : host-array-type(T)))
	let (arr) = inner()
	arr
let host-array-set = lambda_implicit (T : host-type)
	lambda (arr : host-array-type(T), index : host-number, elem : T)
		let inner = intrinsic
			""""
				local function array_set(array, index, elem)
					-- we have to clone because can't guarantee input array isn't reused
					-- Yet. growth mindset.
					cloned = {}
					for i, v in ipairs(array) do
						cloned[i] = v
					end
					cloned[index] = elem
					return cloned
				end
				return array_set
			:
			host-func-type (arr : host-array-type(T), index : host-number, elem : T) -> ((arr : host-array-type(T)))
		let (arr) = inner(arr, index, elem)
		arr
let host-array-get = lambda_implicit (T : host-type)
	lambda (arr : host-array-type(T), index : host-number)
		let inner = intrinsic
			""""
				local function array_get(array, index)
					return U.notail(array[index])
				end
				return array_get
			:
			host-func-type (arr : host-array-type(T), index : host-number) -> ((elem : T))
		let (elem) = inner(arr, index)
		elem

let terms-gen-array = new-host-type(new-host-unique-id("terms-gen-array"))

let void =
	unwrap
		intrinsic
			""""
				local desc = terms.empty
				local basetype = terms.strict_value.enum_type(desc:unwrap_strict())
				return basetype
			:
			wrapped type

let host-unit = new-host-type(new-host-unique-id("host-unit"))
let host-nil = intrinsic "return nil" : host-unit

let tuple-to-host-tuple =
	lambda_implicit (desc : tuple-desc-type(host-type))
		lambda (xs : tuple-type(desc))
			let inner =
				intrinsic
					""""
						return function(val) return base_env.tuple_to_host_tuple_inner(nil, nil, val) end
					:
					host-func-type ((val : wrapped(tuple-type(desc)))) -> ((res : wrapped(host-tuple-type(desc))))
			let (res) = inner(wrap(xs))
			unwrap(res)

let tuple-of = lambda (U : universe, desc : tuple-desc-type(U))
	lambda_single (t : tuple-type(desc))
		t
let host-tuple-of = lambda (desc : tuple-desc-type(host-type))
	intrinsic "return function(...) return ... end" :
		host-func-type (t : host-tuple-type(desc)) -> (t : host-tuple-type(desc))

let tuple-desc-empty = lambda (U : universe)
	let empty = intrinsic "return terms.empty:unwrap_strict()" : wrapped(tuple-desc-type(U))
	unwrap(empty)
let tuple-desc-elem-explicit = lambda (U : universe)
	let U-tuple-desc-type = tuple-desc-type(U)
	unwrap
		intrinsic
			""""
				return U.notail(evaluator.gen_base_operator("#tuple-desc-elem-explicit", function(desc, elem)
					return U.notail(terms.typed_cons(desc, elem))
				end))
			:
			wrapped(forall (desc : U-tuple-desc-type, elem : (forall (rest : tuple-type(desc)) -> (next : U))) -> (res : U-tuple-desc-type))

let tuple-desc-singleton = lambda (U : universe, T : U)
	tuple-desc-elem-explicit(U)
		tuple-desc-empty U
		lambda ()
			T

let tuple-desc-concat-indep = lambda_implicit (U : universe)
	unwrap
		intrinsic
			""""
				return U.notail(evaluator.gen_base_operator("#tuple-desc-concat", function(prefix, suffix)
					return U.notail(terms.typed_term.tuple_desc_concat_indep(prefix, suffix))
				end))
			:
			wrapped (forall (pfx : tuple-desc-type(U), sfx : tuple-desc-type(U)) -> (res : tuple-desc-type(U)))

let host-tuple-concat = lambda (
		head : tuple-desc-type(host-type),
		tail : tuple-desc-type(host-type),
		hd   : host-tuple-type(head),
		tl   : host-tuple-type(tail))
	let inner = intrinsic
		""""
			local value_array = terms_gen.declare_array(terms_gen.any_lua_type)
			local function host_tuple_concat(head, tail)
				local head_elements = head:unwrap_host_tuple_value()
				local tail_elements = tail:unwrap_host_tuple_value()
				local new_elements = value_array()
				for _, e in head_elements:ipairs() do
					new_elements:append(e)
				end
				for _, e in tail_elements:ipairs() do
					new_elements:append(e)
				end
				return U.notail(terms.strict_value.host_tuple_value(new_elements))
			end
			return host_tuple_concat
		:
		host-func-type (
				hd : wrapped(host-tuple-type(head)),
				tl : wrapped(host-tuple-type(tail)))
			->
			((cat : wrapped(host-tuple-type(tuple-desc-concat-indep(head, tail)))))
	let (cat) = inner(wrap(hd), wrap(tl))
	unwrap(cat)

let host-if = lambda_implicit (T : type-omega)
	unwrap
		intrinsic
			""""
				return U.notail(evaluator.gen_base_operator("#host-if", function(subject, consequent, alternate)
					return U.notail(terms.typed_term.host_if(subject, consequent, alternate))
				end))
			:
			wrapped(forall (subject : host-bool, consequent : T, alternate : T) -> (res : T))

let tuple-desc-empty = lambda (U : universe)
	let empty = intrinsic "return terms.empty:unwrap_strict()" : wrapped(tuple-desc-type(U))
	unwrap(empty)
let tuple-desc-elem-explicit = lambda (U : universe)
	let U-tuple-desc-type = tuple-desc-type(U)
	unwrap
		intrinsic
			""""
				return U.notail(evaluator.gen_base_operator("#tuple-desc-elem-explicit", function(desc, elem)
					return U.notail(terms.typed_cons(desc, elem))
				end))
			:
			wrapped(forall (desc : U-tuple-desc-type, elem : (forall (rest : tuple-type(desc)) -> (next : U))) -> (res : U-tuple-desc-type))

let tuple-desc-elem-implicit = lambda_implicit (U : universe)
	tuple-desc-elem-explicit U

let host-number-fold-indep = lambda_implicit (T : type-omega)
	unwrap
		intrinsic
			""""
				return U.notail(evaluator.gen_base_operator("#int-fold", function(num, func, acc)
					return U.notail(terms.typed_term.host_int_fold(num, func, acc))
				end))
			:
			wrapped((forall (n : host-number, f : (forall (i  : host-number, acc  : T) -> (resacc  : T)), acc  : T) -> (res : T)))

let duplicate-tuple-desc = lambda_implicit (U : universe)
	lambda (n : host-number, T : U)
		host-number-fold-indep
			n
			lambda (i : host-number, acc : tuple-desc-type(U))
				tuple-desc-concat-indep
					acc
					tuple-desc-singleton U T
			tuple-desc-empty U

let host-array-from-tuple = lambda_implicit (T : host-type)
	lambda (size : host-number, tuple : host-tuple-type(duplicate-tuple-desc(size, T)))
		let inner =
			intrinsic
				""""
					return function(tuple)
						local elements = tuple:unwrap_host_tuple_value(tuple)
						return {elements:unpack()}
					end
				:
				host-func-type ((tuple : wrapped(host-tuple-type(duplicate-tuple-desc(size, T))))) -> ((res : host-array-type(T)))
		let (array) = inner(wrap(tuple))
		array

let make-host-array = lambda_implicit (T : host-type)
	lambda (size : host-number)
		let input-desc = duplicate-tuple-desc(size, T)
		let host-input-type = host-tuple-type(input-desc)
		let input-type = tuple-type(input-desc)
		let inner =
			intrinsic
				""""
					return function(tuple)
						local elements = tuple:unwrap_host_tuple_value(tuple)
						return {elements:unpack()}
					end
				:
				host-func-type ((tuple : wrapped(host-input-type))) -> ((res : host-array-type(T)))
		lambda_single (elems : input-type)
			let host-elems = tuple-to-host-tuple(elems)
			let (array) = inner(wrap(host-elems))
			array

## syntax matcher and operative stuff

let host-literal = new-host-type(new-host-unique-id("literal"))

let host-expression-args = new-host-type(new-host-unique-id("expression-args"))
let expression-args-new = intrinsic "return alicorn_expressions.ExpressionArgs.new" :
	host-func-type (goal : host-goal, env : host-environment) -> ((args : host-expression-args))

let host-shadow-environment = new-host-type(new-host-unique-id("shadow-environment"))
let host-purity = new-host-type(new-host-unique-id("purity"))
let enter-block = intrinsic
	""""
		-- wish environment.enter_block was accessible from internals
		local function enter_block(env)
			return U.notail(env:enter_block(terms.block_purity.pure))
		end
		return enter_block
	:
	host-func-type ((env : host-environment)) -> (shadowed : host-shadow-environment, inner : host-environment)
let exit-block = intrinsic
	""""
		-- wish environment.exit_block was accessible from internals
		local function exit_block(inner, term, shadowed)
			return U.notail(inner:exit_block(term, shadowed))
		end
		return exit_block
	:
	host-func-type (
			inner    : host-environment,
			term     : host-inferrable-term,
			shadowed : host-shadow-environment)
		->
		(env : host-environment, wrapped : host-inferrable-term, purity : host-purity)

let host-matcher = new-host-type-family new-host-unique-id("matcher")
	forall (userdata : host-type, result : tuple-desc-type(host-type)) -> (T : host-type)
	tuple-of-implicit contravariant(subtyping) covariant(tuple-desc-relation)

let nil-handler-type = lambda (userdata : host-type, result : tuple-desc-type(host-type))
	host-func-type ((ud : userdata)) -> (r : host-tuple-type(result))
let host-matcher-is-nil = lambda (userdata : host-type, result : tuple-desc-type(host-type), accept-handler : nil-handler-type(userdata, result))
	let inner = intrinsic "return metalanguage.isnil" :
		host-func-type ((accept-handler : nil-handler-type(userdata, result))) -> ((m : host-matcher(userdata, result)))
	let (m) = inner(accept-handler)
	m

let pair-handler-type = lambda (userdata : host-type, result : tuple-desc-type(host-type))
	host-func-type (ud : userdata, a : host-syntax, b : host-syntax) -> (r : host-tuple-type(result))
let host-matcher-is-pair = lambda (userdata : host-type, result : tuple-desc-type(host-type), accept-handler : pair-handler-type(userdata, result))
	let inner = intrinsic "return metalanguage.ispair" :
		host-func-type ((accept-handler : pair-handler-type(userdata, result))) -> ((m : host-matcher(userdata, result)))
	let (m) = inner(accept-handler)
	m

let symbol-handler-type = lambda (userdata : host-type, result : tuple-desc-type(host-type))
	host-func-type (ud : userdata, symbol : host-string) -> (r : host-tuple-type(result))
let host-matcher-is-symbol = lambda (userdata : host-type, result : tuple-desc-type(host-type), accept-handler : symbol-handler-type(userdata, result))
	let inner = intrinsic "return metalanguage.issymbol" :
		host-func-type ((accept-handler : symbol-handler-type(userdata, result))) -> ((m : host-matcher(userdata, result)))
	let (m) = inner(accept-handler)
	m

let value-handler-type = lambda (userdata : host-type, result : tuple-desc-type(host-type))
	host-func-type (ud : userdata, val : host-literal) -> (r : host-tuple-type(result))
let host-matcher-is-value = lambda (userdata : host-type, result : tuple-desc-type(host-type), accept-handler : value-handler-type(userdata, result))
	let inner = intrinsic "return metalanguage.isvalue" :
		host-func-type ((accept-handler : value-handler-type(userdata, result))) -> ((m : host-matcher(userdata, result)))
	let (m) = inner(accept-handler)
	m

let reducer-type = new-host-type-family new-host-unique-id("host-reducer")
	forall (storage : tuple-desc-type(host-type), result2 : tuple-desc-type(host-type)) -> (T : host-type)
	tuple-of-implicit contravariant(tuple-desc-relation) covariant(tuple-desc-relation)

let reducible-handler-type = lambda (userdata : host-type, result2 : tuple-desc-type(host-type), result : tuple-desc-type(host-type))
	# prepend userdata to result2
	let userdata-desc = tuple-desc-singleton(host-type, userdata)
	let params = tuple-desc-concat-indep(userdata-desc, result2)
	host-func-type (p : host-tuple-type(params)) -> (r : host-tuple-type(result))
let reducible-constructor-type = lambda (
		userdata : host-type,
		storage  : tuple-desc-type(host-type),
		result2  : tuple-desc-type(host-type),
		result   : tuple-desc-type(host-type))
	let accept-handler-type = reducible-handler-type(userdata, result2, result)
	# prepend accept-handler-type to storage
	let accept-handler-desc = tuple-desc-singleton(host-type, accept-handler-type)
	let params = tuple-desc-concat-indep(accept-handler-desc, storage)
	host-func-type (p : host-tuple-type(params)) -> ((m : host-matcher(userdata, result)))
let get-reducible-constructor = lambda (
		userdata : host-type,
		storage  : tuple-desc-type(host-type),
		result2  : tuple-desc-type(host-type),
		result   : tuple-desc-type(host-type),
		red      : reducer-type(storage, result2))
	let inner = intrinsic "return function(r) return r end" :
		host-func-type ((r : reducer-type(storage, result2))) -> ((c : reducible-constructor-type(userdata, storage, result2, result)))
	let (c) = inner(red)
	c

let host-matcher-reducible =
	lambda_implicit (userdata       : host-type)
		lambda (
				storage        : tuple-desc-type(host-type),
				result2        : tuple-desc-type(host-type),
				result         : tuple-desc-type(host-type),
				red            : reducer-type(storage, result2),
				s              : host-tuple-type(storage),
				accept-handler : reducible-handler-type(userdata, result2, result))
			# FIXME: this function resolution breaks alicorn, which is extremely very super bad
			# let c = get-reducible-constructor(userdata, storage, result2, result, red)
			let inner = intrinsic "return function(r) return r end" :
				host-func-type ((r : reducer-type(storage, result2))) -> ((c : reducible-constructor-type(userdata, storage, result2, result)))
			let (c) = inner(red)

			let accept-handler-type = reducible-handler-type(userdata, result2, result)
			let accept-handler-desc = tuple-desc-singleton(host-type, accept-handler-type)
			# let red-param-desc = tuple-desc-concat(host-type, accept-handler-desc, storage)
			# let red-result-desc = tuple-desc-singleton(host-type, host-matcher(userdata, result))

			let accept-handler-tuple = host-tuple-of(accept-handler-desc)(accept-handler)
			let red-param = host-tuple-concat(accept-handler-desc, storage, accept-handler-tuple, s)

			# look ma, no intrinsics!
			let (m) = apply(c, red-param)
			m

let failure-handler-type = lambda (userdata : host-type, result : tuple-desc-type(host-type))
	host-func-type (ud : userdata, exception : host-lua-error) -> (r : host-tuple-type(result))

let match-syntax = lambda (
		userdata        : host-type,
		result          : tuple-desc-type(host-type),
		matchers        : host-array-type(host-matcher(userdata, result)),
		failure-handler : failure-handler-type(userdata, result),
		syn             : host-syntax,
		ud              : userdata)
	let inner = intrinsic
		""""
			local function match_syntax(matchers, failure_handler, syn, ud)
				return U.notail(syn:match(matchers, failure_handler, ud))
			end
			return match_syntax
		:
		host-func-type (
				matchers        : host-array-type(host-matcher(userdata, result)),
				failure-handler : failure-handler-type(userdata, result),
				syn             : host-syntax,
				ud              : wrapped(userdata))
			->
			(r : host-tuple-type(result))
	inner(matchers, failure-handler, syn, wrap(ud))

let host-term-of-inner = intrinsic
	""""
		local function host_term_of(goal)
			if goal:is_infer() then
				return terms.host_inferrable_term_type
			elseif goal:is_check() then
				return terms.host_checkable_term_type
			else
				error("host-term-of: unknown goal")
			end
		end
		return host_term_of
	:
	host-func-type ((goal : host-goal)) -> ((t : wrapped(host-type)))
#let host-term-of-inner = hackhack-host-term-of-inner
let host-term-of = lambda (goal : host-goal)
	let (t) = host-term-of-inner(goal)
	unwrap(t)
let goalify-inferrable = intrinsic
	""""
		local function goalify_inferrable(goal, inferrable)
			if goal:is_infer() then
				return inferrable
			elseif goal:is_check() then
				return U.notail(terms.checkable_term.inferrable(inferrable))
			else
				error("goalify-inferrable: unknown goal")
			end
		end
		return goalify_inferrable
	:
	host-func-type (goal : host-goal, inferrable : host-inferrable-term) -> ((term : host-term-of(goal)))

let operative-handler-type = lambda (userdata : host-type)
	forall (syn : host-syntax, env : host-environment, ud : userdata, goal : host-goal) -> (term : host-term-of(goal), env : host-environment)

let operative-result-desc = lambda (goal : host-goal)
	# read as: (term : host-term-of(goal), env : host-environment)
	tuple-desc-concat-indep
		tuple-desc-singleton(host-type, host-term-of(goal))
		tuple-desc-singleton(host-type, host-environment)

# alicorn doesn't have conds or branches yet so...
let error-filter = lambda (Tt : host-type, Tf : host-type, ok : host-bool, val-or-err : host-if(ok, Tt, Tf))
	let inner = intrinsic
		""""
			local function error_filter(ok, val_or_err)
				if not ok then
					error(val_or_err)
				end
				return val_or_err
			end
			return error_filter
		:
		host-func-type (ok : host-bool, val-or-err : host-if(ok, Tt, Tf)) -> ((val : Tt))
	let (val) = inner(ok, val-or-err)
	val

let core-operative-type =
	unwrap
		intrinsic
			""""
				return base_env.core_operative_type
			:
			wrapped(forall (userdata : host-type, handler : operative-handler-type(userdata)) -> (res : host-type))


let core-operative = lambda_implicit (userdata : host-type)
	unwrap
		intrinsic
			""""
				return base_env.core_operative
			:
			wrapped(forall (ud : userdata, handler : operative-handler-type(userdata)) -> (res : core-operative-type(userdata, handler)))

## tuple-desc operative

let ascribed-segment-tuple-desc-reducer-thread-type = new-host-type(new-host-unique-id("ascribed-segment-tuple-desc-reducer-thread"))
let ascribed-segment-tuple-desc-reducer-thread-type-get-names = intrinsic
	""""
		local function get_names(thread)
			return thread.names
		end
		return get_names
	:
	host-func-type ((thread : ascribed-segment-tuple-desc-reducer-thread-type)) -> ((names : terms-gen-array))
let ascribed-segment-tuple-desc-reducer-thread-type-get-args = intrinsic
	""""
		local function get_args(thread)
			return thread.args
		end
		return get_args
	:
	host-func-type ((thread : ascribed-segment-tuple-desc-reducer-thread-type)) -> ((args : host-inferrable-term))
let ascribed-segment-tuple-desc-reducer-thread-type-get-env = intrinsic
	""""
		local function get_env(thread)
			return thread.env
		end
		return get_env
	:
	host-func-type ((thread : ascribed-segment-tuple-desc-reducer-thread-type)) -> ((env : host-environment))

let ascribed-segment-tuple-desc-reducer-storage-desc = tuple-desc-singleton(host-type, host-environment)

let ascribed-segment-tuple-desc-reducer-result2-desc = tuple-desc-singleton(host-type, ascribed-segment-tuple-desc-reducer-thread-type)

let ascribed-segment-tuple-desc-match-result-desc =
	# read as: (ok : host-bool, _ : host-if(ok, ascribed-segment-tuple-desc-reducer-thread-type, host-lua-error))
	# or, more logically: (ok : host-bool, ...) where:
	# - ok == true:  `...` is ascribed-segment-tuple-desc-reducer-thread-type
	# - ok == false: `...` is host-lua-error
	# technically this should have a third element in the ok == true case, containing host-syntax
	# but the syntax will always be nil, and the errors are annoying
	tuple-desc-elem-implicit
		tuple-desc-elem-explicit(host-type)
			tuple-desc-empty host-type
			lambda ()
				host-bool
		lambda (ok : host-bool)
			host-if(ok, ascribed-segment-tuple-desc-reducer-thread-type, host-lua-error)

# FIXME: ascribed_segment_tuple_desc can only produce tuple descs in star-0
let ascribed-segment-tuple-desc-reducer = intrinsic "return base_env.ascribed_segment_tuple_desc" :
	reducer-type(ascribed-segment-tuple-desc-reducer-storage-desc, ascribed-segment-tuple-desc-reducer-result2-desc)

let ascribed-segment-tuple-desc-match-accept-handler = intrinsic "return metalanguage.accept_handler" :
	reducible-handler-type(host-unit, ascribed-segment-tuple-desc-reducer-result2-desc, ascribed-segment-tuple-desc-match-result-desc)
let ascribed-segment-tuple-desc-match-failure-handler = intrinsic "return metalanguage.failure_handler" :
	failure-handler-type(host-unit, ascribed-segment-tuple-desc-match-result-desc)

let tuple-desc-impl-type = operative-handler-type(host-unit)

let tuple-desc-impl = lambda (syn : host-syntax, env : host-environment, ud : host-unit, goal : host-goal)
	let s = host-tuple-of(ascribed-segment-tuple-desc-reducer-storage-desc)(env)

	let matcher-t = host-matcher(host-unit, ascribed-segment-tuple-desc-match-result-desc)
	let matcher =
		host-matcher-reducible
			ascribed-segment-tuple-desc-reducer-storage-desc
			ascribed-segment-tuple-desc-reducer-result2-desc
			ascribed-segment-tuple-desc-match-result-desc
			ascribed-segment-tuple-desc-reducer
			s
			ascribed-segment-tuple-desc-match-accept-handler

	let matchers =
		host-array-set
			host-array-new matcher-t
			1
			matcher

	let (ok, thread) =
		match-syntax
			host-unit
			ascribed-segment-tuple-desc-match-result-desc
			matchers
			ascribed-segment-tuple-desc-match-failure-handler
			syn
			host-nil

	let thread = error-filter(ascribed-segment-tuple-desc-reducer-thread-type, host-lua-error, ok, thread)

	let (args) = ascribed-segment-tuple-desc-reducer-thread-type-get-args(thread)
	let (env) = ascribed-segment-tuple-desc-reducer-thread-type-get-env(thread)

	let (args) = goalify-inferrable(goal, args)

	tuple-of(host-type, operative-result-desc(goal))(args, env)

#let (tuple-desc-op-type, tuple-desc) = new-operative(host-unit, host-nil, tuple-desc-impl)
let tuple-desc = core-operative(host-nil, tuple-desc-impl)
# tuple-desc for single-element tuples currently require an extra pair of parens, like lambdas used to.
# This should eventually be fixed the same way lambdas were fixed.

let host-tuple-to-tuple =
	lambda_implicit (desc : tuple-desc-type(host-type))
		lambda (xs : host-tuple-type(desc))
			let inner = intrinsic
				""""
					return function(val)
						local elems = val:unwrap_host_tuple_value()
						local vals = terms_gen.declare_array(terms.strict_value)()
						for _, v in ipairs(elems) do
							vals:append(terms.strict_value.host_value(v))
						end
						return U.notail(terms.strict_value.tuple_value(vals))
					end
				:
				host-func-type ((
						val   : wrapped(host-tuple-type(desc))))
					->
					((res : wrapped(tuple-type(desc))))
			let (res) = inner(wrap(xs))
			the tuple-type(desc) unwrap(res)

let func-to-host-func =
	lambda_curry (arg-desc : tuple-desc-type(host-type), res-desc : (forall (x : tuple-type(arg-desc)) -> (r : tuple-desc-type(host-type))))
		let ft = forall (args : tuple-type(arg-desc)) -> (res : tuple-type(apply(res-desc, args)))
		let hft = host-func-type (args : host-tuple-type(arg-desc)) -> (res : host-tuple-type(apply(res-desc, host-tuple-to-tuple(args))))
		lambda (f : ft)
			let inner = intrinsic
				""""
					return function(afn)
						return function(...)
							local args = table.pack(...)
							local conv_args = terms_gen.declare_array(terms.flex_value)()
							for i = 1, args.n do
								conv_args:append(terms.flex_value.host_value(args[i]))
							end
							local res = evaluator.apply_value(terms.flex_value.strict(afn), terms.flex_value.tuple_value(conv_args), terms.typechecking_context())
							if not res:is_tuple_value() then
								error "alicorn function converted to native function has failed to create a real value"
							end
							local elems = {}
							for i, v in res:unwrap_tuple_value():ipairs() do
								elems[i] = v:unwrap_host_value()
							end
							return table.unpack(elems)
						end
					end
				:
				host-func-type ((arg : wrapped(ft))) -> ((res : hft))
			let (res) = inner(wrap(f))
			the hft res



##### GLSL PRELUDE START HERE #####

let wgpu-bool = host-bool
let wgpu-float = host-number
let wgpu-vec2 = new-host-type(new-host-unique-id("wgpu-vec2"))
let wgpu-vec3 = new-host-type(new-host-unique-id("wgpu-vec3"))
let wgpu-vec4 = new-host-type(new-host-unique-id("wgpu-vec4"))
let wgpu-mat4 = new-host-type(new-host-unique-id("wgpu-mat4"))

let host-add-float = intrinsic
	""""
		local host_add_float = function(l, r) return l + r end
		glsl_registry[host_add_float] = function(pp, varnames, l, r)
			pp:unit("(")
			pp:any(l, varnames)
			pp:unit(" + ")
			pp:any(r, varnames)
			pp:unit(")")
		end
		return host_add_float
	:
	host-func-type (left : wgpu-float, right : wgpu-float) -> ((sum : wgpu-float))
let _+_ = lambda (left : wgpu-float, right : wgpu-float)
	let (sum) = host-add-float(left, right)
	sum

let host-sub-float = intrinsic
	""""
		local host_sub_float = function(l, r) return l - r end
		glsl_registry[host_sub_float] = function(pp, varnames, l, r)
			pp:unit("(")
			pp:any(l, varnames)
			pp:unit(" - ")
			pp:any(r, varnames)
			pp:unit(")")
		end
		return host_sub_float
	:
	host-func-type (left : wgpu-float, right : wgpu-float) -> ((difference : wgpu-float))
let _-_ = lambda (left : wgpu-float, right : wgpu-float)
	let (difference) = host-sub-float(left, right)
	difference

let host-mul-float = intrinsic
	""""
		local host_mul_float = function(l, r) return l * r end
		glsl_registry[host_mul_float] = function(pp, varnames, l, r)
			pp:unit("(")
			pp:any(l, varnames)
			pp:unit(" * ")
			pp:any(r, varnames)
			pp:unit(")")
		end
		return host_mul_float
	:
	host-func-type (left : wgpu-float, right : wgpu-float) -> ((product : wgpu-float))
let _*_ = lambda (left : wgpu-float, right : wgpu-float)
	let (product) = host-mul-float(left, right)
	product

let host-mul-vec2 = intrinsic
	""""
		local host_mul_vec2 = function(l, r) return setmetatable({
				x = l.x * r.x,
				y = l.y * r.y,
			}, glsl_registry["vec2f"]) end
		glsl_registry[host_mul_vec2] = function(pp, varnames, l, r)
			pp:unit("(")
			pp:any(l, varnames)
			pp:unit(" * ")
			pp:any(r, varnames)
			pp:unit(")")
		end
		return host_mul_vec2
	:
	host-func-type (left : wgpu-vec2, right : wgpu-vec2) -> ((product : wgpu-vec2))
let _:*:_ = lambda (left : wgpu-vec2, right : wgpu-vec2)
	let (product) = host-mul-vec2(left, right)
	product

let host-mul-vec4 = intrinsic
	""""
		local host_mul_vec4 = function(l, r) return setmetatable({
				x = l.x * r.x,
				y = l.y * r.y,
				z = l.z * r.z,
				w = l.w * r.w,
			}, glsl_registry["vec4f"]) end
		glsl_registry[host_mul_vec4] = function(pp, varnames, l, r)
			pp:unit("(")
			pp:any(l, varnames)
			pp:unit(" * ")
			pp:any(r, varnames)
			pp:unit(")")
		end
		return host_mul_vec4
	:
	host-func-type (left : wgpu-vec4, right : wgpu-vec4) -> ((product : wgpu-vec4))
let _::*::_ = lambda (left : wgpu-vec4, right : wgpu-vec4)
	let (product) = host-mul-vec4(left, right)
	product

let mul-vec4 = lambda (left : wgpu-vec4, right : wgpu-vec4)
	let (product) = host-mul-vec4(left, right)
	product

# doesn't work???
let host-mul-gen = intrinsic
	""""
		local host_mul = function(t, u, l, r) 
			local t = {}
			if getmetatable(l) and getmetatable(r) then
				for k, v in pairs(l) do
					t[k] = v * r[k]
				end
				return setmetatable(t, getmetatable(l))
			elseif getmetatable(l) then
				for k, v in pairs(l) do
					t[k] = v * r
				end
				return setmetatable(t, getmetatable(l))
			elseif getmetatable(r) then
				for k, v in pairs(r) do
					t[k] = v * l
				end
				return setmetatable(t, getmetatable(r))
			else
				return l * r 
			end
		end
		glsl_registry[host_mul] = function(pp, varnames, l, r)
			pp:unit("(")
			pp:any(l, varnames)
			pp:unit(" * ")
			pp:any(r, varnames)
			pp:unit(")")
		end
		return host_mul
	:
	host-func-type (T : wrapped(host-type), U : wrapped(host-type), left : unwrap(T), right : unwrap(U)) -> ((product : unwrap(T)))
#let _*_ = lambda (left : wgpu-float, right : wgpu-float)
#	let (product) = host-mul-gen(wrap(wgpu-float), wrap(wgpu-float), left, right)
#	product
#let _:*._ = lambda (left : wgpu-vec2, right : wgpu-float)
#	let (product) = host-mul-gen(wrap(wgpu-vec2), wrap(wgpu-float), left, right)
#	product
#let _:*:_ = lambda (left : wgpu-vec2, right : wgpu-vec2)
#	let (product) = host-mul-gen(wrap(wgpu-vec2), wrap(wgpu-vec2), left, right)
#	product
#let _::*._ = lambda (left : wgpu-vec4, right : wgpu-float)
#	let (product) = host-mul-gen(wrap(wgpu-vec4), wrap(wgpu-vec4), left, right)
#	product
#let _::*::_ = lambda (left : wgpu-vec4, right : wgpu-vec4)
#	let (product) = host-mul-gen(wrap(wgpu-vec4), wrap(wgpu-vec4), left, right)
#	product

let host-div-float = intrinsic
	""""
		local host_div_float = function(l, r) return l / r end
		glsl_registry[host_div_float] = function(pp, varnames, l, r)
			pp:unit("(")
			pp:any(l, varnames)
			pp:unit(" / ")
			pp:any(r, varnames)
			pp:unit(")")
		end
		return host_div_float
	:
	host-func-type (left : wgpu-float, right : wgpu-float) -> ((quotient : wgpu-float))
let _/_ = lambda (left : wgpu-float, right : wgpu-float)
	let (quotient) = host-div-float(left, right)
	quotient

let host-lt-float = intrinsic
	""""
		local host_lt_float = function(l, r) return l < r end
		glsl_registry[host_lt_float] = function(pp, varnames, l, r)
			pp:unit("(")
			pp:any(l, varnames)
			pp:unit(" < ")
			pp:any(r, varnames)
			pp:unit(")")
		end
		return host_lt_float
	:
	host-func-type (left : wgpu-float, right : wgpu-float) -> ((result : wgpu-bool))
let _<_ = lambda (left : wgpu-float, right : wgpu-float)
	let (result) = host-lt-float(left, right)
	result

let host-gt-float = intrinsic
	""""
		local host_gt_float = function(l, r) return l > r end
		glsl_registry[host_gt_float] = function(pp, varnames, l, r)
			pp:unit("(")
			pp:any(l, varnames)
			pp:unit(" > ")
			pp:any(r, varnames)
			pp:unit(")")
		end
		return host_gt_float
	:
	host-func-type (left : wgpu-float, right : wgpu-float) -> ((result : wgpu-bool))
let _>_ = lambda (left : wgpu-float, right : wgpu-float)
	let (result) = host-gt-float(left, right)
	result

let host-clamp = intrinsic
	""""
		local host_clamp = function(x, minVal, maxVal)
			if x < minVal then
				return minVal
			elseif x > maxVal then
				return maxVal
			else
				return x
			end
		end
		glsl_registry[host_clamp] = function(pp, varnames, x, minVal, maxVal)
			pp:unit("clamp(")
			pp:any(x, varnames)
			pp:unit(", ")
			pp:any(minVal, varnames)
			pp:unit(", ")
			pp:any(maxVal, varnames)
			pp:unit(")")
		end
		return host_clamp
	:
	host-func-type (x : wgpu-float, minVal : wgpu-float, maxVal : wgpu-float) -> ((clamped : wgpu-float))
let clamp = lambda (x : wgpu-float, minVal : wgpu-float, maxVal : wgpu-float)
	let (clamped) = host-clamp(x, minVal, maxVal)
	clamped

let host-max = intrinsic
	""""
		local host_max = function(x, minVal)
			if x < minVal then
				return minVal
			else
				return x
			end
		end
		glsl_registry[host_max] = function(pp, varnames, x, minVal)
			pp:unit("max(")
			pp:any(x, varnames)
			pp:unit(", ")
			pp:any(minVal, varnames)
			pp:unit(")")
		end
		return host_max
	:
	host-func-type (x : wgpu-float, maxVal : wgpu-float) -> ((maxed : wgpu-float))
let max = lambda (x : wgpu-float, maxVal : wgpu-float)
	let (maxed) = host-max(x, maxVal)
	maxed

let host-min = intrinsic
	""""
		local host_min = function(x, minVal)
			if x > minVal then
				return minVal
			else
				return x
			end
		end
		glsl_registry[host_min] = function(pp, varnames, x, minVal)
			pp:unit("min(")
			pp:any(x, varnames)
			pp:unit(", ")
			pp:any(minVal, varnames)
			pp:unit(")")
		end
		return host_min
	:
	host-func-type (x : wgpu-float, minVal : wgpu-float) -> ((mined : wgpu-float))
let min = lambda (x : wgpu-float, minVal : wgpu-float)
	let (mined) = host-min(x, minVal)
	mined
	
let host-ternary = intrinsic
	""""
		local host_ternary = function(condition, consequent, alternate)
			if condition then
				return consequent
			else
				return alternate
			end
		end
		glsl_registry[host_ternary] = function(pp, varnames, condition, consequent, alternate)
			pp:unit("select(")
			pp:any(alternate, varnames)
			pp:unit(", ")
			pp:any(consequent, varnames)
			pp:unit(", ")
			pp:any(condition, varnames)
			pp:unit(")")
		end
		return host_ternary
	:
	host-func-type (condition : wgpu-bool, consequent : wgpu-float, alternate : wgpu-float) -> ((result : wgpu-float))
let ternary = lambda (condition : wgpu-bool, consequent : wgpu-float, alternate : wgpu-float)
	let (result) = host-ternary(condition, consequent, alternate)
	result

let host-fwidth = intrinsic
	""""
		-- This returns the derivative of the values relative to the current surface dimensions, which is not possible to do here
		local host_fwidth = function(v) return 1.0	end
		glsl_registry[host_fwidth] = function(pp, varnames, v)
			pp:unit("fwidth(")
			pp:any(v, varnames)
			pp:unit(")")
		end
		return host_fwidth
	:
	host-func-type ((v : wgpu-float)) -> ((result : wgpu-float))
let fwidth = lambda (v : wgpu-float)
	let (result) = host-fwidth(v)
	result

let host-dot = intrinsic
	""""
		local host_dot = function(l, r) return l.x * r.x + l.y * r.y	end
		glsl_registry[host_dot] = function(pp, varnames, l, r)
			pp:unit("dot(")
			pp:any(l, varnames)
			pp:unit(", ")
			pp:any(r, varnames)
			pp:unit(")")
		end
		return host_dot
	:
	host-func-type (l : wgpu-vec2, r : wgpu-vec2) -> ((result : wgpu-float))
let dot = lambda (l : wgpu-vec2, r : wgpu-vec2)
	let (result) = host-dot(l, r)
	result
	
let host-normalize = intrinsic
	""""
		local host_normalize = function(v) 
			local l = math.sqrt(v.x * v.x + v.y * v.y) 
			return setmetatable({x = v.x / l, y = v.y / l}, glsl_registry["vec2f"])
		end
		glsl_registry[host_normalize] = function(pp, varnames, v)
			pp:unit("normalize(")
			pp:any(v, varnames)
			pp:unit(")")
		end
		return host_normalize
	:
	host-func-type ((v : wgpu-vec2)) -> ((result : wgpu-vec2))
let normalize = lambda (v : wgpu-vec2)
	let (result) = host-normalize(v)
	result

let host-length = intrinsic
	""""
		local host_length = function(v) return math.sqrt(v.x * v.x + v.y * v.y) end
		glsl_registry[host_length] = function(pp, varnames, v)
			pp:unit("length(")
			pp:any(v, varnames)
			pp:unit(")")
		end
		return host_length
	:
	host-func-type ((v : wgpu-vec2)) -> ((result : wgpu-float))
let length = lambda (v : wgpu-vec2)
	let (result) = host-length(v)
	result

let host-mk-vec2 = intrinsic
	""""
		local vec2_mt = {}
		local host_mk_vec2 = function(x, y) return setmetatable({ x = x, y = y }, vec2_mt) end
		glsl_registry[host_mk_vec2] = function(pp, varnames, x, y)
			pp:unit("vec2f(")
			pp:any(x, varnames)
			pp:unit(", ")
			pp:any(y, varnames)
			pp:unit(")")
		end
		glsl_registry[vec2_mt] = function(pp, vec, varnames)
			return glsl_registry[host_mk_vec2](pp, varnames, vec.x, vec.y)
		end
		glsl_registry["vec2f"] = vec2_mt
		return host_mk_vec2
	:
	host-func-type (x : wgpu-float, y : wgpu-float) -> ((vec : wgpu-vec2))
let mk-vec2 = lambda (x : wgpu-float, y : wgpu-float)
	let (vec) = host-mk-vec2(x, y)
	vec
let mk-vec2-float = lambda (x : wgpu-float)
	let (vec) = host-mk-vec2(x, x)
	vec

let host-get-vec2-x = intrinsic
	""""
		local host_get_vec2_x = function(vec) return vec.x end
		glsl_registry[host_get_vec2_x] = function(pp, varnames, vec)
			pp:any(vec, varnames)
			pp:unit(".x")
		end
		return host_get_vec2_x
	:
	host-func-type ((vec : wgpu-vec2)) -> ((x : wgpu-float))
let host-get-vec2-y = intrinsic
	""""
		local host_get_vec2_y = function(vec) return vec.y end
		glsl_registry[host_get_vec2_y] = function(pp, varnames, vec)
			pp:any(vec, varnames)
			pp:unit(".y")
		end
		return host_get_vec2_y
	:
	host-func-type ((vec : wgpu-vec2)) -> ((y : wgpu-float))
let split-vec2 = lambda (vec : wgpu-vec2)
	let (x) = host-get-vec2-x(vec)
	let (y) = host-get-vec2-y(vec)
	tuple-of-implicit(x, y)

let host-add-vec2 = intrinsic
	""""
		local host_add_vec2 = function(l, r)
			return setmetatable({
				x = l.x + r.x,
				y = l.y + r.y,
			}, glsl_registry["vec2f"])
		end
		glsl_registry[host_add_vec2] = function(pp, varnames, l, r)
			pp:unit("(")
			pp:any(l, varnames)
			pp:unit(" + ")
			pp:any(r, varnames)
			pp:unit(")")
		end
		return host_add_vec2
	:
	host-func-type (left : wgpu-vec2, right : wgpu-vec2) -> ((sum : wgpu-vec2))
let add-vec2 = lambda (left : wgpu-vec2, right : wgpu-vec2)
	let (sum) = host-add-vec2(left, right)
	sum

let host-add-vec4 = intrinsic
	""""
		local host_add_vec4 = function(l, r)
			return setmetatable({
				x = l.x + r.x,
				y = l.y + r.y,
				z = l.z + r.z,
				w = l.w + r.w,
			}, glsl_registry["vec4f"])
		end
		glsl_registry[host_add_vec4] = function(pp, varnames, l, r)
			pp:unit("(")
			pp:any(l, varnames)
			pp:unit(" + ")
			pp:any(r, varnames)
			pp:unit(")")
		end
		return host_add_vec4
	:
	host-func-type (left : wgpu-vec4, right : wgpu-vec4) -> ((sum : wgpu-vec4))
let add-vec4 = lambda (left : wgpu-vec4, right : wgpu-vec4)
	let (sum) = host-add-vec4(left, right)
	sum

let host-sub-vec2 = intrinsic
	""""
		local host_sub_vec2 = function(l, r)
			return setmetatable({
				x = l.x - r.x,
				y = l.y - r.y,
			}, glsl_registry["vec2f"])
		end
		glsl_registry[host_sub_vec2] = function(pp, varnames, l, r)
			pp:unit("(")
			pp:any(l, varnames)
			pp:unit(" - ")
			pp:any(r, varnames)
			pp:unit(")")
		end
		return host_sub_vec2
	:
	host-func-type (left : wgpu-vec2, right : wgpu-vec2) -> ((difference : wgpu-vec2))
let sub-vec2 = lambda (left : wgpu-vec2, right : wgpu-vec2)
	let (difference) = host-sub-vec2(left, right)
	difference

let host-abs-vec2 = intrinsic
	""""
		local host_abs_vec2 = function(vec)
			return setmetatable({
				x = math.abs(vec.x),
				y = math.abs(vec.y),
			}, glsl_registry["vec2f"])
		end
		glsl_registry[host_abs_vec2] = function(pp, varnames, vec)
			pp:unit("abs(")
			pp:any(vec, varnames)
			pp:unit(")")
		end
		return host_abs_vec2
	:
	host-func-type ((vec : wgpu-vec2)) -> ((result : wgpu-vec2))
let abs-vec2 = lambda (vec : wgpu-vec2)
	let (result) = host-abs-vec2(vec)
	result
	
let host-abs-float = intrinsic
	""""
		local host_abs_float = function(v)
			return math.abs(v)
		end
		glsl_registry[host_abs_float] = function(pp, varnames, v)
			pp:unit("abs(")
			pp:any(v, varnames)
			pp:unit(")")
		end
		return host_abs_float
	:
	host-func-type ((v : wgpu-float)) -> ((result : wgpu-float))
let abs = lambda (v : wgpu-float)
	let (result) = host-abs-float(v)
	result
	
let host-pow-float = intrinsic
	""""
		local host_pow_float = function(v, p)
			return math.pow(v, p)
		end
		glsl_registry[host_pow_float] = function(pp, varnames, v, p)
			pp:unit("pow(")
			pp:any(v, varnames)
			pp:unit(", ")
			pp:any(p, varnames)
			pp:unit(")")
		end
		return host_pow_float
	:
	host-func-type (v : wgpu-float, p : wgpu-float) -> ((result : wgpu-float))
let pow = lambda (v : wgpu-float, p : wgpu-float)
	let (result) = host-pow-float(v, p)
	result

let host-mk-vec4 = intrinsic
	""""
		local vec4_mt = {}
		local host_mk_vec4 = function(x, y, z, w) return setmetatable({ x = x, y = y, z = z, w = w }, vec4_mt) end
		glsl_registry[host_mk_vec4] = function(pp, varnames, x, y, z, w)
			pp:unit("vec4f(")
			pp:any(x, varnames)
			pp:unit(", ")
			pp:any(y, varnames)
			pp:unit(", ")
			pp:any(z, varnames)
			pp:unit(", ")
			pp:any(w, varnames)
			pp:unit(")")
		end
		glsl_registry[vec4_mt] = function(pp, vec, varnames)
			return glsl_registry[host_mk_vec4](pp, varnames, vec.x, vec.y, vec.z, vec.w)
		end
		glsl_registry["vec4f"] = vec4_mt
		return host_mk_vec4
	:
	host-func-type (x : wgpu-float, y : wgpu-float, z : wgpu-float, w : wgpu-float) -> ((vec : wgpu-vec4))
let mk-vec4 = lambda (x : wgpu-float, y : wgpu-float, z : wgpu-float, w : wgpu-float)
	let (vec) = host-mk-vec4(x, y, z, w)
	vec
let mk-vec4-float = lambda (x : wgpu-float)
	let (vec) = host-mk-vec4(x, x, x, x)
	vec

let host-get-vec4-x = intrinsic
	""""
		local host_get_vec4_x = function(vec) return vec.x end
		glsl_registry[host_get_vec4_x] = function(pp, varnames, vec)
			pp:any(vec, varnames)
			pp:unit(".x")
		end
		return host_get_vec4_x
	:
	host-func-type ((vec : wgpu-vec4)) -> ((x : wgpu-float))
let host-get-vec4-y = intrinsic
	""""
		local host_get_vec4_y = function(vec) return vec.y end
		glsl_registry[host_get_vec4_y] = function(pp, varnames, vec)
			pp:any(vec, varnames)
			pp:unit(".y")
		end
		return host_get_vec4_y
	:
	host-func-type ((vec : wgpu-vec4)) -> ((y : wgpu-float))
let host-get-vec4-z = intrinsic
	""""
		local host_get_vec4_z = function(vec) return vec.z end
		glsl_registry[host_get_vec4_z] = function(pp, varnames, vec)
			pp:any(vec, varnames)
			pp:unit(".z")
		end
		return host_get_vec4_z
	:
	host-func-type ((vec : wgpu-vec4)) -> ((z : wgpu-float))
let host-get-vec4-w = intrinsic
	""""
		local host_get_vec4_w = function(vec) return vec.w end
		glsl_registry[host_get_vec4_w] = function(pp, varnames, vec)
			pp:any(vec, varnames)
			pp:unit(".w")
		end
		return host_get_vec4_w
	:
	host-func-type ((vec : wgpu-vec4)) -> ((w : wgpu-float))
let split-vec4 = lambda (vec : wgpu-vec4)
	let (x) = host-get-vec4-x(vec)
	let (y) = host-get-vec4-y(vec)
	let (z) = host-get-vec4-z(vec)
	let (w) = host-get-vec4-w(vec)
	tuple-of-implicit(x, y, z, w)

let host-mk-mat4 = intrinsic
	""""
		local mat4_mt = {}
		local host_mk_mat4 = function(a, b, c, d)
			return setmetatable({
				ax = a.x, bx = b.x, cx = c.x, dx = d.x,
				ay = a.y, by = b.y, cy = c.y, dy = d.y,
				az = a.z, bz = b.z, cz = c.z, dz = d.z,
				aw = a.w, bw = b.w, cw = c.w, dw = d.w,
			}, mat4_mt)
		end
		glsl_registry[host_mk_mat4] = function(pp, varnames, a, b, c, d)
			pp:unit("mat4x4f(")
			pp:any(a, varnames)
			pp:unit(", ")
			pp:any(b, varnames)
			pp:unit(", ")
			pp:any(c, varnames)
			pp:unit(", ")
			pp:any(d, varnames)
			pp:unit(")")
		end
		glsl_registry[mat4_mt] = function(pp, mat, varnames)
			pp:unit("/* NYI: repr a mat4! */")
		end
		glsl_registry["mat4x4f"] = mat4_mt
		return host_mk_mat4
	:
	host-func-type (a : wgpu-vec4, b : wgpu-vec4, c : wgpu-vec4, d : wgpu-vec4) -> ((mat : wgpu-mat4))
let mk-mat4 = lambda (a : wgpu-vec4, b : wgpu-vec4, c : wgpu-vec4, d : wgpu-vec4)
	let (mat) = host-mk-mat4(a, b, c, d)
	mat

let host-mul-mat4-vec4 = intrinsic
	""""
		local host_mul_mat4_vec4 = function(left, right)
			return setmetatable({
				x = left.ax * right.x + left.bx * right.y + left.cx * right.z + left.dx * right.w,
				y = left.ay * right.x + left.by * right.y + left.cy * right.z + left.dy * right.w,
				z = left.az * right.x + left.bz * right.y + left.cz * right.z + left.dz * right.w,
				w = left.aw * right.x + left.bw * right.y + left.cw * right.z + left.dw * right.w,
			}, glsl_registry["vec4f"])
		end
		glsl_registry[host_mul_mat4_vec4] = function(pp, varnames, left, right)
			pp:unit("(")
			pp:any(left, varnames)
			pp:unit(" * ")
			pp:any(right, varnames)
			pp:unit(")")
		end
		return host_mul_mat4_vec4
	:
	host-func-type (left : wgpu-mat4, right : wgpu-vec4) -> ((product : wgpu-vec4))
let mul-mat4-vec4 = lambda (left : wgpu-mat4, right : wgpu-vec4)
	let (product) = host-mul-mat4-vec4(left, right)
	product

let host-mul-mat4-mat4 = intrinsic
	""""
		local host_mul_mat4_mat4 = function(left, right)
			return setmetatable({
				ax = left.ax * right.ax + left.bx * right.ay + left.cx * right.az + left.dx * right.aw,
				ay = left.ay * right.ax + left.by * right.ay + left.cy * right.az + left.dy * right.aw,
				az = left.az * right.ax + left.bz * right.ay + left.cz * right.az + left.dz * right.aw,
				aw = left.aw * right.ax + left.bw * right.ay + left.cw * right.az + left.dw * right.aw,

				bx = left.ax * right.bx + left.bx * right.by + left.cx * right.bz + left.dx * right.bw,
				by = left.ay * right.bx + left.by * right.by + left.cy * right.bz + left.dy * right.bw,
				bz = left.az * right.bx + left.bz * right.by + left.cz * right.bz + left.dz * right.bw,
				bw = left.aw * right.bx + left.bw * right.by + left.cw * right.bz + left.dw * right.bw,

				cx = left.ax * right.cx + left.bx * right.cy + left.cx * right.cz + left.dx * right.cw,
				cy = left.ay * right.cx + left.by * right.cy + left.cy * right.cz + left.dy * right.cw,
				cz = left.az * right.cx + left.bz * right.cy + left.cz * right.cz + left.dz * right.cw,
				cw = left.aw * right.cx + left.bw * right.cy + left.cw * right.cz + left.dw * right.cw,

				dx = left.ax * right.dx + left.bx * right.dy + left.cx * right.dz + left.dx * right.dw,
				dy = left.ay * right.dx + left.by * right.dy + left.cy * right.dz + left.dy * right.dw,
				dz = left.az * right.dx + left.bz * right.dy + left.cz * right.dz + left.dz * right.dw,
				dw = left.aw * right.dx + left.bw * right.dy + left.cw * right.dz + left.dw * right.dw,
			}, glsl_registry["mat4x4"])
		end
		glsl_registry[host_mul_mat4_mat4] = function(pp, varnames, left, right)
			pp:unit("(")
			pp:any(left, varnames)
			pp:unit(" * ")
			pp:any(right, varnames)
			pp:unit(")")
		end
		return host_mul_mat4_mat4
	:
	host-func-type (left : wgpu-mat4, right : wgpu-mat4) -> ((product : wgpu-mat4))
let mul-mat4-mat4 = lambda (left : wgpu-mat4, right : wgpu-mat4)
	let (product) = host-mul-mat4-mat4(left, right)
	product

############# SHADER DEFINITIONS

let frag-shader-type = forall (pos : wgpu-vec2, PosDim : wgpu-vec4, DimBorderBlur : wgpu-vec4, Corners : wgpu-vec4, Fill : wgpu-vec4, Outline : wgpu-vec4) -> ((glfragcolor : wgpu-vec4))

let wgpu-print-frag-shader = intrinsic
	""""
		local U = require "alicorn-utils"
		local format = require "format"
		return function(frag_shader)
			local param_name, code, capture, _capture_dbg, _param_debug = frag_shader:unwrap_closure()
			local context = terms.strict_runtime_context()
			context = context:append(terms.strict_value.host_number_type, "#frag-context", terms.var_debug("#frag-context-dbg", format.anchor_here()))
			context = context:append(terms.strict_value.host_number_type, param_name, terms.var_debug("#frag-closure-dbg", format.anchor_here()))
			local elements = code:unwrap_tuple_cons()
			local glfragcolor = elements[1]:glsl_print({{}, {"pos", "PosDim", "DimBorderBlur", "Corners", "Fill", "Outline"}})
			local boilerplate = "@group(0) @binding(1)\nvar<uniform> PosDim: vec4f;\n@group(0) @binding(2) \nvar<uniform> DimBorderBlur: vec4f;\n@group(0) @binding(3) \nvar<uniform> Corners: vec4f;\n@group(0) @binding(4) \nvar<uniform> Fill: vec4f;\n@group(0) @binding(5) \nvar<uniform> Outline: vec4f;"
			local frag_shader = boilerplate .. "@fragment \nfn main(@location(0) pos: vec2f) -> @location(0) vec4f {\n return " .. glfragcolor .. ";\n}\n"
			return frag_shader
		end
	:
	host-func-type ((frag-shader : wrapped(frag-shader-type))) -> ((str : host-string))

let linearstep = lambda (low : wgpu-float, high : wgpu-float, x : wgpu-float)
	clamp((x - low) / (high - low), 0, 1)

let rectangle = lambda (samplePosition : wgpu-vec2, halfSize : wgpu-vec2, edges : wgpu-vec4)
	let (samplePosition-x, samplePosition-y) = split-vec2(samplePosition)
	let (edges-x, edges-y, edges-z, edges-w) = split-vec4(edges)
	let edge = ternary (samplePosition-x > 0)
		ternary(samplePosition-y < 0, edges-y, edges-z)
		ternary(samplePosition-y < 0, edges-x, edges-w)
	let componentWiseEdgeDistance = add-vec2
		sub-vec2(abs-vec2(samplePosition), halfSize)
		mk-vec2(edge, edge)
	
	let (componentWiseEdgeDistance-x, componentWiseEdgeDistance-y) = split-vec2(componentWiseEdgeDistance)
	let outsideDistance = length(mk-vec2(max(componentWiseEdgeDistance-x, 0.0), max(componentWiseEdgeDistance-y, 0.0)))
	let insideDistance = min(max(componentWiseEdgeDistance-x, componentWiseEdgeDistance-y), 0.0)
	outsideDistance + insideDistance - edge

let rect-frag-shader = lambda (pos : wgpu-vec2, PosDim : wgpu-vec4, DimBorderBlur : wgpu-vec4, Corners : wgpu-vec4, Fill : wgpu-vec4, Outline : wgpu-vec4)
	let (PosDim-x, PosDim-y, PosDim-z, PosDim-w) = split-vec4(PosDim)
	let (DimBorderBlur-x, DimBorderBlur-y, DimBorderBlur-z, DimBorderBlur-w) = split-vec4(DimBorderBlur)
	let (pos-x, pos-y) = split-vec2(pos)

	let w = fwidth((PosDim-z * pos-x)) * 0.5 * (1.0 + DimBorderBlur-w);
	let uv = mk-vec2((pos-x * PosDim-z) - (PosDim-z * 0.5), (pos-y * PosDim-w) - (PosDim-w * 0.5))

	let dist = rectangle(uv, mk-vec2(PosDim-z * 0.5, PosDim-w * 0.5), Corners);
	let alpha = linearstep(w, w * -1.0, dist)
	let s = linearstep(w, w * -1.0, dist + DimBorderBlur-z)

	let (Fill-r, Fill-g, Fill-b, Fill-a) = split-vec4(Fill)
	let (Outline-r, Outline-g, Outline-b, Outline-a) = split-vec4(Outline)
	let c = clamp(alpha - s, 0.0, 1.0)

	let premultiply-fill = mk-vec4(Fill-r * Fill-a * s, Fill-g * Fill-a * s, Fill-b * Fill-a * s, Fill-a * s)
	let premultiply-outline = mk-vec4(Outline-r * Outline-a * c, Outline-g * Outline-a * c, Outline-b * Outline-a * c, Outline-a * c)
	let output = add-vec4(premultiply-fill, premultiply-outline)
	tuple-of-implicit(output)

let (rect-frag-shader-string) = wgpu-print-frag-shader(wrap(rect-frag-shader))

let line-to-point = lambda (p1 : wgpu-vec2, p2 : wgpu-vec2, p : wgpu-vec2)
	let n = sub-vec2(p2, p1)
	let (n-x, n-y) = split-vec2(n)
	dot(normalize(mk-vec2(n-y, -1.0 * n-x)), sub-vec2(p1, p))

let triangle-frag-shader = lambda (pos : wgpu-vec2, PosDim : wgpu-vec4, DimBorderBlur : wgpu-vec4, Corners : wgpu-vec4, Fill : wgpu-vec4, Outline : wgpu-vec4)
	let (PosDim-x, PosDim-y, PosDim-z, PosDim-w) = split-vec4(PosDim)
	let (Corners-x, Corners-y, Corners-z, Corners-w) = split-vec4(Corners)
	let (DimBorderBlur-x, DimBorderBlur-y, DimBorderBlur-z, DimBorderBlur-w) = split-vec4(DimBorderBlur)
	let d = mk-vec2(PosDim-z, PosDim-w)
	let (d-x, d-y) = split-vec2(d)
	let p = add-vec2(pos :*: d, mk-vec2(-0.5 , 0.5))
	let p2 = mk-vec2(Corners-w * d-x, 0.0)
	let r1 = line-to-point(p2, mk-vec2(0.0, d-y), p)
	let r2 = -1.0 * line-to-point(p2, d, p)
	let (p-x, p-y) = split-vec2(p)
	let r = max(max(r1, r2), p-y - d-y)

	let w = fwidth(p-x) * (1.0 + DimBorderBlur-w)
	let s = 1.0 - linearstep(1.0 - DimBorderBlur-z - w * 2.0, 1.0 - DimBorderBlur-z - w, r)
	let alpha = linearstep(1.0 - w, 1.0 - w * 2.0, r)  
	let (Fill-r, Fill-g, Fill-b, Fill-a) = split-vec4(Fill)
	let (Outline-r, Outline-g, Outline-b, Outline-a) = split-vec4(Outline)
	let fill-alpha = mul-vec4(mk-vec4(Fill-r, Fill-g, Fill-b, 1.0), mk-vec4-float(Fill-a * s))
	let outline-alpha = mul-vec4(mk-vec4(Outline-r, Outline-g, Outline-b, 1.0), mk-vec4-float(Outline-a * clamp(alpha - s,0.0,1.0)))
	let output = add-vec4(fill-alpha, outline-alpha)
	tuple-of-implicit(output)

let (tri-frag-shader-string) = wgpu-print-frag-shader(wrap(triangle-frag-shader))

let circle-frag-shader = lambda (pos : wgpu-vec2, PosDim : wgpu-vec4, DimBorderBlur : wgpu-vec4, Corners : wgpu-vec4, Fill : wgpu-vec4, Outline : wgpu-vec4)
	let (PosDim-x, PosDim-y, PosDim-z, PosDim-w) = split-vec4(PosDim)
	let (Corners-x, Corners-y, Corners-z, Corners-w) = split-vec4(Corners)
	let (DimBorderBlur-x, DimBorderBlur-y, DimBorderBlur-z, DimBorderBlur-w) = split-vec4(DimBorderBlur)
	let l = (PosDim-z + PosDim-w) * 0.5
	let (pos-x, pos-y) = split-vec2(pos)
	let uv = sub-vec2(mk-vec2(pos-x * 2.0, pos-y * 2.0), mk-vec2-float(1.0))
	let w1 = (1.0 + DimBorderBlur-w) * fwidth(pos-x) 

	let border = (DimBorderBlur-z / l) * 2.0
	let t = 0.50 - (Corners-x / l)
	let r = 1.0 - t - w1

	let inner = (Corners-y / l) * 2.0
	let pre = length(uv) - r + (border * 0.5) - (inner * 0.5)
	let abspre = abs(pre)
	let d0 = abspre - t + (border * 0.5) + (inner * 0.5)
	let d1pre = length(uv) - r
	let d1 = abs(d1pre) - t
	let s = pow(linearstep(w1 * 2.0, 0.0, d0), 2.2)
	let alpha = pow(linearstep(w1 * 2.0, 0.0, d1), 2.2)

	let (Fill-r, Fill-g, Fill-b, Fill-a) = split-vec4(Fill)
	let (Outline-r, Outline-g, Outline-b, Outline-a) = split-vec4(Outline)
	
	let fill-alpha = mul-vec4(mk-vec4(Fill-r, Fill-g, Fill-b, 1.0), mk-vec4-float(Fill-a * s))
	let outline-alpha = mul-vec4(mk-vec4(Outline-r, Outline-g, Outline-b, 1.0), mk-vec4-float(Outline-a * clamp(alpha - s, 0.0, 1.0)))
	let output = add-vec4(fill-alpha, outline-alpha)
	tuple-of-implicit(output)

let (circle-frag-shader-string) = wgpu-print-frag-shader(wrap(circle-frag-shader))

############# FEATHER LAYOUT STARTS HERE

# We start by binding our feather types to Rust interface that's been exposed via our lua bindings in feather.
# First we declare some new opaque types that feather will be manipulating entirely via the lua bindings, without
# knowing what's inside the types. This includes our URect, a rectangle with a absolute and relative coordinates, 
# the Component, which is the underlying trait that all feather outlines satisfy (like buttons or labels), and
# an event handler, which is used to capture mouse input.

let string = host-string

#	---@alias URect userdata
let URect = new-host-type(new-host-unique-id("URect"))

#	---@alias Component userdata
let Component = new-host-type(new-host-unique-id("Component"))

#	---@alias EventHandler userdata
let EventHandler = new-host-type(new-host-unique-id("EventHandler"))

# We also define an ID type, which is intended to uniquely identify every component. This will be used for
# referencing components from inside each other.

let FeatherID = new-host-type(new-host-unique-id("FeatherID"))

# Each pair of functions here binds an alicorn function to a lua function. The first function assigns a type
# to the lua function intrinsic, and the second function creates an alicorn-friendly function that then calls
# the lua intrinsic. We repeat this for every function we have exposed through the lua interface.

####
	---@param left number
	---@param top number
	---@param right number
	---@param bottom number
	---@param rel_left number
	---@param rel_top number
	---@param rel_right number
	---@param rel_bottom number
	---@return URect
	function create_urect(left, top, right, bottom, rel_left, rel_top, rel_right, rel_bottom)
	end
let create-urect-bind =
	intrinsic
		"return create_urect"
		:
		host-func-type
			(
				left : host-number,
				top : host-number,
				right : host-number,
				bottom : host-number,
				rel_left : host-number,
				rel_top : host-number,
				rel_right : host-number,
				rel_bottom : host-number
			)
			->
			((res : URect))
let create-urect =
	lambda
		(
			left : host-number,
			top : host-number,
			right : host-number,
			bottom : host-number,
			rel_left : host-number,
			rel_top : host-number,
			rel_right : host-number,
			rel_bottom : host-number
		)
		let (res) = create-urect-bind(left, top, right, bottom, rel_left, rel_top, rel_right, rel_bottom)
		res

let create-id-bind =
	intrinsic "return create_id" : (host-func-type ((id  : string)) -> ((res  : FeatherID)))
let create-id = lambda (id  : string)
	let  (res)  = create-id-bind(id)
	res

####
	---@param name string
	---@param child Component
	---@return Component
	function create_window(name, child) end
let create-window-bind =
	intrinsic
		"return create_window"
		:
		host-func-type (id : FeatherID, name : string, child : Component) -> ((res : Component))
let create-window =
	lambda (id : FeatherID, name : string, child : Component)
		let (res) = create-window-bind(id, name, child)
		res
####
	---@param area URect
	---@param ... Component
	---@return Component
	function create_region(area, ...) end
let create-region-bind =
	intrinsic
		""""
			return function(id, area, components) print('inside create-region', components) return create_region(id, area, components) end
		:
		host-func-type (id : FeatherID, area : URect, components : host-array-type(Component)) -> ((res : Component))

let create-region =
	lambda (id : FeatherID, area : URect, components : host-array-type(Component))
		let (res) = create-region-bind(id, area, components)
		res

####
	---@param area URect
	---@param text string
	---@param onclick EventHandler
	---@param background Component
	---@return Component
	function create_button(area, text, onclick, background) end
let create-button-bind =
	intrinsic
		"return create_button"
		:
		host-func-type (id : FeatherID, area : URect, text : string, onclick : EventHandler, background : Component) -> ((res : Component))
let create-button =
	lambda (id : FeatherID, area : URect, text : string, onclick : EventHandler, background : Component)
		let (res) = create-button-bind(id, area, text, onclick, background)
		res
####
	---@param area URect
	---@param text string
	---@return Component
	function create_label(area, text) end
let create-label-bind =
	intrinsic "return create_label" : (host-func-type (id : FeatherID, area : URect, text : string) -> ((res : Component)))

let create-label =
	lambda (id : FeatherID, area : URect, text : string)
		let (res) = create-label-bind(id, area, text)
		res

####
	---Colors here are 32-bit RGBA integers (for now): 0xFF00FFFF
	---@param area URect
	---@param color integer
	---@param radius number
	---@param border number
	---@param bordercolor integer
	---@return Component
	function create_round_rect(area, color, radius, border, bordercolor) end
let create-round-rect-bind =
	intrinsic
		"return create_round_rect"
		:
		host-func-type (id : FeatherID, area : URect, color : host-number, radius : host-number, border : host-number, bordercolor : host-number) -> ((res : Component))
let create-round-rect =
	lambda (id : FeatherID, area : URect, color : host-number, radius : host-number, border : host-number, bordercolor : host-number)
		let (res) = create-round-rect-bind(id, area, color, radius, border, bordercolor)
		res

let create-shader-standard-bind =
	intrinsic
		"return create_shader_standard"
		:
		host-func-type (id : FeatherID, area : URect, source : host-string, dimborderblur : host-array-type(host-number), corners : host-array-type(host-number), fill : host-array-type(host-number), outline : host-array-type(host-number)) -> ((res : Component))
let create-shader-standard =
	lambda (id : FeatherID, area : URect, source : host-string, dimborderblur : host-array-type(host-number), corners : host-array-type(host-number), fill : host-array-type(host-number), outline : host-array-type(host-number))
		let (res) = create-shader-standard-bind(id, area, source, dimborderblur, corners, fill, outline)
		res

# These function signatures are a bit confusing, but basically, they represent the full signatures of an alicorn function that 
# we will be calling from Rust. In order to accomplish this, we need to express the alicorn function signature using lua types,
# so that we can create a wrapper that calls it from lua. We can then return this lua wrapper function to Rust, which will call it
# from inside our Rust backend. While this sounds complicated, it's the exact same operation one would do when doing C FFI to
# communicate between two languages, we're just using Lua instead of C as the intermediary. 
# Alicorn(windowmaker) -> Lua(Alicorn(windowmaker)) -> mlua -> Rust(Lua(Alicorn(windowmaker))) -> [helper rust function that calls Rust(Lua(Alicorn(windowmaker)))]

# This is the signature for the "windowmaker" function
let windowsig = host-func-type (store : host-unit, appstate : host-unit) -> (store : host-unit, window : Component)
# this is the signature for the "init" function
let initsig = host-func-type () -> ((res : host-unit))
# This is the function for the "onclick" function
let onclicksig = host-func-type (dispatch : host-unit, state : host-unit) -> ((result : host-unit))

let uidesc = tuple-desc(
	window : windowsig,
	init : initsig,
	onclick :  onclicksig)

# This is our main function that must satisfy the App::Call() trait in Rust. This means it must return two things: a persistent
# store (currently unused), and our final assembled Window component. For convenience, we assemble the rest of our layout inside
# this function and add it directly to our window.
let windowmaker = lambda (store : host-unit, appstate : host-unit) # : (store : host-unit, window : Component)
	let urect-label = create-urect(0.0, 0.0, 1280.0, 720.0, 0.0, 0.0, 0.0, 0.0)
	let urect-btn = create-urect(100.0, 100.0, 300.0, 200.0, 0.0, 0.0, 0.0, 0.0)
	let urect-tri = create-urect(100.0, 250.0, 300.0, 350.0, 0.0, 0.0, 0.0, 0.0)
	let urect-circ = create-urect(400.0, 250.0, 500.0, 350.0, 0.0, 0.0, 0.0, 0.0)
	let components = host-array-new(Component)
	let components = host-array-set(components, 1, create-label(create-id("hello-label"), urect-label, "Hello World, from alicorn in feather!"))
	#let components = host-array-set(components, 2, create-round-rect(create-id("hello-rect"), urect-btn, 4294967295, 10.0, 0.0, 0))
	let zero_array = (make-host-array(4) 0.0 0.0 0.0 0.0)
	let corners = (make-host-array(4) 10.0 10.0 10.0 10.0)
	let color = (make-host-array(4) 0.2 0.7 0.4 1.0)
	let components = host-array-set(components, 2, create-shader-standard(create-id("hello-rect"), urect-btn, rect-frag-shader-string, zero_array, corners, color, zero_array))
	let components = host-array-set(components, 3, create-shader-standard(create-id("hello-tri"), urect-tri, tri-frag-shader-string, zero_array, zero_array, color, zero_array))
	let components = host-array-set(components, 4, create-shader-standard(create-id("hello-circ"), urect-circ, circle-frag-shader-string, zero_array, zero_array, color, zero_array))
	let region = create-region(create-id("main-region"), urect-label, components)
	let window = create-window(create-id("main-window"), "Hello World, from alicorn in feather!", region)
	tuple-of-implicit store window

let init = lambda () # : ((res : host-unit))
	tuple-of-implicit host-nil

let onclick = lambda (dispatch  : host-unit, state  : host-unit)
	tuple-of-implicit host-nil

# This is our final UI description, which includes our window creation function, our init() function (currently empty) and
# our onclick event (currently unused)
let res =
	host-tuple-of(uidesc)
		func-to-host-func
			windowmaker
		func-to-host-func
			init
		func-to-host-func
			onclick

res